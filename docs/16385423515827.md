设计模式学习

# 目的

1.对于每一个设计思想，原则，模式有一个清晰的认识，知道它适应于什么样的业务场景

2.要用swift 实现课程中的实战项目

3.思考如何将这个设计思想/原则/模式，应用在项目中，并要对已有的项目做重构

4.在以后写代码的时候，要多加思考是否可以使用这种设计模式，已有的代码是否违背某种设计原则/思想/模式



**囫囵吐枣的学完，不如细致的学会重点的部分**


# 面向对象的基本特征及各解决什么问题
- [x] 封装
- [x] 继承
- [x] 多态
- [x] 抽象

是什么和解决了什么问题？语法层面需要哪些支持

1.封装
是什么：将实现细节封装到类/方法
解决了：数据安全、隐藏细节、职责单一等问题
语法支持：访问权限关键字

从这个层面讲，model应该封装一些数据操作的方法，而不是纯粹承担模型的功能。不然就会导致model的数据操作，散落在各处 有很多缺点：代码无法复用；数据安全无法缺乏保证


2.继承
是什么：解决了is-a问题，比如猫是一种哺乳动物
解决了：代码复用，一般/特殊的问题
语法继承：iOS中是“：”

3.多态
是什么：子类可以替换父类，具体实现替换协议类型
解决了：同一段代码，根据传入的对象不同，有不同的表现
语法支持: 继承，接口/实现

4.抽象
是什么：分离接口和实现，识别可能变化的部分
解决了：多态、开闭原则、代码扩展等问题
语法支持：protocol、interface、抽象类等

# 接口和抽象类
## 区别
抽象类可以包含属性和方法实现；接口只能定义方法，不能包含属性和方法实现。
抽象类不可以创建对象，只能被继承。
子类继承抽象类，必须重写里面的抽象方法。

## 选择
抽象类:关注于代码复用，并要求子类必须重写抽象方法。可惜iOS语法层面不支持，不然像哪些大的基类，都应该用抽象类代替(参考【子类过多override的缺陷】的实现，在一定程度上规避)。

接口:调用者只用关心接口，而不是具体实现。**将接口和实现分离。基于稳定的接口，灵活扩展不稳定/可能会变的实现，提高代码灵活性/扩展性**。

## 面向接口编程的重要技巧
封装具体的细节。某个实现才需要的方法，**即不那么通用的逻辑，不需要暴露在接口中**。

# 多用组合而不是继承
项目现状：
AirBrush中的FeatureBaseComponet作为基类，承担了太多的责任：
- 订阅
- 图片保存
- 设置UI
- 动画

大部分放到基类其实问题不大，但是有两个需要仔细设计下。订阅和多人脸
订阅：业务特点是，不是所有功能都需要订阅，目前虽然把这个放到了基类，但是还有一些限时免费的功能需要在子类处理，比如限时免费；付费的功能 每个都需要监听订阅通知，完成之后隐藏banner，这部分是重复的逻辑。 其实就很适合将订阅单独为插件，所有订阅逻辑 其实都是一样的，可以统一处理。

多人脸：业务特点是部分功能需要，且处理逻辑 基本一样。如果放到基类，就很容易造成基类过于庞大，且很多功能并不需要这部分逻辑。也很适合使用组合的方式。

## 继承的优缺点
优点：代码复用

缺点：
- 层次结构深的话代码不易理解；
- 过度耦合，修改父类，影响子类的行为；
- 容易写出一些四不像的代码，比如为了复用，将一些代码强行到父类。

## 什么样的场景适合使用组合，而不是继承：

首先继承的目的，是代码复用。所以一般也是代码复用的场景，才会考虑使用组合/继承。

**一些模块化的代码，只是部分子类需要，但不是所有子类都需要。
出于复用的目的，可以将这部分代码抽象为插件，而不是强行放到基类。**

举个例子，大部分鸟，会飞、会叫、会下单。但也有特例，比如鸵鸟/企鹅 不会飞；实际中鸟是这些特征的任意组合（类似上面AirBrush中的例子）。在代码中不可能将所有可能组合，每一种可能定义一个基类吧。所以就适合使用组合。

```
1.将每种能力，定义为协议
protocol Flyable {
 func fly()
}

protocol Tweetable {
    func tweet()
}

protocol EggLayable {
    func egg()
}

2.我们知道协议只是声明，并没有实现。所以我们添加默认实现

public class FlyAbility implements Flyable { 
@Override public void fly() { 
    //... 
    }
}

3.使用的时候

public class Ostrich implements Tweetable, EggLayable {//鸵鸟 

private TweetAbility tweetAbility = new TweetAbility(); //组合 private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 
    
    //... 省略其他属性和方法... 
    @Override public void tweet() { 
        tweetAbility.tweet(); // 委托 
    } 

    @Override public void layEgg() { 
        eggLayAbility.layEgg(); // 委托 
    }
}

```

## 组合的缺点
优点：**避免了四不像基类的设计，以更细的颗粒去复用代码**。
缺点：需要更多的接口和类，增加维护和理解成本。

# 面相对象分析、设计、编程

这三个分别是什么？怎么做？有没有一些套路？

面向对象分析，约等于需求分析。
只有将需求分析的足够细致、明确才能完整的对需求建模。

分析&设计 阶段似乎没有固定的章法，但是有明确的目标：
- 首先肯定是理解清楚需求，知道是要干什么的，每一步是是什么，关键细节有哪些
- 建模：搞清楚有哪些类、每个类都哪些属性、方法、类之间如何通信；是否需要组件化；层次化
- 高阶一点的：未来哪些可能会变，留好扩展点；性能问题；安全问题

可能算是的技巧吧：
- 提取名词当做候选类，提取动词当做方法
- 罗列列出功能点，把职责相近的划分到一起



# 设计原则
每个设计原则是什么？怎么判断一个类、设计 是否遵循这个原则？解决哪些问题？如何实现？即从定义、判断标准、目的、实现等多个视角看待

## 单一职责
定义：一个类、模块只负责一个功能。
辩证：一个类是否满足单一职责，在不同发展阶段，不同的业务视角可能会有不同的结论。且过犹不及
目的：提高代码复用性、可读性，有利于实现高内聚、低耦合。
实现：不要写大而全的类，要设计粒度小、职责单一的类


## 开闭原则 【最重要的】
定义：对扩展开放，对修改关闭
我的理解：在不改变主流程的基础上，针对一个特定的功能 支持做一些自定义的操作；针对可能变化的部分，外部可以替换为自定义实现。

如何做到？
- 识别变化，预留扩展点
- 面向协议编程，用稳定的接口代替不稳定的实现

关键在于：
识别可能会变化的部分

设计模式、语法层面支持：
>最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）
>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。


目的：提高代码复用(反例 AB中的duffle每个功能写一套)，

>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

## 里氏替换原则
定义：子类能够替换父类，而不改变程序的结果和正确性。
通俗一点的说法：子类和父类，在输入校验、业务逻辑、结果输出上应当保持一致。即子类只是父类的增强，但不会改变父类的行为。
判定：针对父类的单元测试，对于子类要同样适用。

与多态的区别：
层面不同：多态是面向对象语言的基本特征，而里氏替换是一种设计原则。
目的不同：多态是实现程序扩展性重要手段，而里氏替换是指导子类如何设计的

目的：一言难尽，不知道有什么场景，有点死板。

## 

## 依赖倒置



# 设计模式

## 创建型
- [x]  单例
- [x] 工厂
- [x] 建造者
## 结构型
- [x] 代理
- [x] 装饰器
- [ ] 适配器
## 行为型
- [x] 观察者
- [x] 模板
- [x] 策略
- [x] 职责链
- [x] 迭代器





# 总结

## 设计模式的目的

设计模式解要干的事情就是**解耦**。

创建型模式解决的是对象创建的问题，将对象的创建和使用解耦；结构型模式解决的类和对象的组装问题，将不同的功能代码解耦；行为型模式解决的是类和对象之间的交互，将不同的行为解耦。

通过设计模式，**将一大坨代码拆分为职责单一的小类**，**让其满足开闭原则，高内聚低耦合，单一职责等特性**。以此达到提高代码可维护性的目的，当需要修改需求的时候，只修改一个单一职责的类或者干脆不用修改代码等，来减少代码维护、测试的成本，以及减少出错的可能性和影响范围。

应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性

## 如何理解面向接口(协议)编程

以前的理解： 通过swift的特性，给协议添加默认实现，依次来代替继承。

现在的理解：

- 协议是一种行为或者能力的抽象，它规定了一些属性或方法，遵循协议的类必须实现协议要求。当遵循协议的对象被当做参数传递到调用方时，调用者并不关心协议对象是如何实现这些要求的，它只管调用即可
- 协议是面向对象语言实现多态的重要手段。一个协议类型，可以代表多个实现协议的【子类型】，使得他们能够作为同一种类型的参数进行传递。进而使得代码满足单一职责、开闭原则等要求，减少在需求变动的时候，代码修改/测试的成本
- 大量的设计模式，都是用了面向接口/协议变成的特点，让代码满足单一职责/开闭原则。

## 如何写出可扩展的代码？

意识层面：应该具备抽象意识、封装意识、扩展意识

具体到业务层面，在写代码之前最好花一段时间想一想哪些未来是会发生变化的，哪些是不会变化的。**对于变化(不稳定)的部分抽象成稳定的接口提供给外部，当需求发生变化的，只需要基于相同的抽象接口扩展出一个新的实现，替换掉老的实现即可，这样外部的代码基本不需要改动。**

## 如何区分工厂模式和建造者模式
工厂模式：用来创建不同但是相关类型的对象（继承同一父类），由给定的参数决定创建哪种类型的对象
建造者模式：用来创建同一种类型的复杂对象，通过设置不同的参数，定制化创建不同的对象



策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。

