# 《程序员的自我修养--第六章--装载》

## 关于虚拟地址空间的理解
1.什么是虚拟地址空间？
以Linux 32为操作系统为例，一个进程的虚拟地址空间如下：
1G 内核空间 + 3G 用户空间。其中用户空间从低地址到高地址依次是：代码段，数据段，堆区，共享库，栈区。
![linux 32位进程虚拟地址空间](media/16413813709226/linux%2032%E4%BD%8D%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

2.为什么要使用虚拟地址空间？
- 地址隔离：每个进程都拥有自己独立的虚拟空间，避免程序直接访问内存，避免程序被其他程序修改。
- 内存使用效率：结合内存分页，提高内存使用效率，支持物理内存的离散使用。相对于之前整段程序加载（静态加载）进内存而言
- 程序运行地址确定：以静态链接为例，在链接之后，程序中代码和数据的地址都确定了，只需要在启动时装载到内存即可，避免了数据和指令的重定位。当然还是需要mmu映射到具体的物理内存
- 利用了disk扩展了内存空间。当空间不够的时候，可以换入换出

## 进程的装载方式
动态装入的原理：程序是有局部性原理的，即程序运行时，一段时间内只有一部分代码经常被用到。所以我们可以将不常用的部分放到磁盘里，用到的时候，在装入内存。

X位操作系统：ALU一次运算的位数，而不是地址总线的位数。

### 覆盖装入 Overlay
相关之间没有业务关联的模块可以覆盖，但是需要程序员手动指定依赖关系。
缺点：
1.需要手动指定依赖关系，繁琐/容易出错
2.粒度大，以模块为单位。进而造成换入换出的效率低，程序执行慢

### 页映射
页映射是虚拟存储的一部分，它将内存和所有磁盘中的数据和指令按照页为单位划分，以后装载和换入换出的单位就是页。一般页是4K大小。

可执行文件中的页可能被加载到物理内存中任意页，如果程序直接使用物理地址进行操作，那么每次装入时都需要进行重定位。所以还是要使用虚拟地址！

## 装载

### 装载的过程
1.创建虚拟地址空间。虚拟地址空间并不存在，这一步其实是建立虚拟地址到物理地址的映射，创建这个映射所需要的数据。
2.建立虚拟地址和可执行文件的映射。当发生缺少错误时，将数据/指令换入内存时，需要知道缺少的那个页(虚拟地址)在可执行文件中的位置。它记录在一个叫VMA，Virtual Memory Address的数据结构中
3.将CPU指令寄存器设置为可执行文件的入口，将控制权交给用户程序。

### page fault 处理流程
1.发现访问页不在内存，触发page fault,将控制权交给操作系统。
2.在物理内存中分配一个页，根据缺少页的VMA，找到它在可执行文件中的位置，将它读入内存，并建立虚拟地址和物理地址的映射
3.将控制权交给进程，进程从页错误的地方**重新**执行。

## 进程的虚拟空间分布

### ELF可执行文件的两种视图
从Section的角度来看就是ELF的链接视图；从Segment为单位来看就是装载视图

#### 为什么要用Segment来划分？
以Section为单位装载，会造成过多的内存碎片浪费内容。**因为一个装载的时候，以页为单位，一个页4K，一个Section常常不够4K**.因此会把权限相同（可读。可写、可执行）的Section合并到一个Segment，一起加载。

#### 两种视图展示
链接视图，查看段表。以Section为单位
![链接视图](media/16413813709226/%E9%93%BE%E6%8E%A5%E8%A7%86%E5%9B%BE.png)

装载视图，查看程序头表。以Segment为单位
![装载视图](media/16413813709226/%E8%A3%85%E8%BD%BD%E8%A7%86%E5%9B%BE.png)
从红框中可以看到，第0个LOAD项合并了若干个Section。

从程序头表中，可以推测出程序在虚拟地址空间的加载地址。
![elf的加载](media/16413813709226/elf%E7%9A%84%E5%8A%A0%E8%BD%BD.png)
第一个LOAD项地址：0x08048000, MemSize: 0x709e5. 0x08048000 + 0x709e5 = 0x080B89E5。按4K即0x1000对齐，因此第二个LOAD项从0x080B9000开始。


#### 程序头表的数据结构

![程序头表数据结构](media/16413813709226/%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

这个数据结构表示程序头表，与上面程序装载视图的输出内容对用。
- p_type: Segment 的类型，一般只关注LOAD类型
- p_offset: Segment在文件中的偏移
- p_addr: Segment 在虚拟地址空间的偏移
- p_memse:Segment 在虚拟地址空间的长度
- p_align: 对齐
 
 ### 堆和栈
 Linux下查看进程的虚拟地址空间分布，Mac下可尝试使用VMMap.
 ![进程地址空间分布](media/16413813709226/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.png)

VMA：虚拟内存区域 Virtual Memory Area.
操作系统通过给进程空间划分为一个个VMA来管理进程的虚拟空间。
划分原则：权限是否相同，是否有映像文件。

一个进程一般可以划分为如下：
- 代码VMA，权限：只读、可执行；有映像文件
- 数据VMA，权限：可读写；有映像文件
- 堆VMA, 权限：可读写，可执行；无映像文件
- 栈VMA, 权限：可读写，不可执行；无映像文件。

我们常说的虚拟空间的Segment就是指的这几个VMA.

![VMA 映射](media/16413813709226/VMA%20%E6%98%A0%E5%B0%84.png)


### Linux进程装载ELF文件的过程简介
Linux可以执行elf, out, script等程序，因此需要根据文件的前128字节判断文件格式，进而调用相应的加载器。以ELF 格式为例：
1.检查ELF文件的有效性，如ELF魔数，程序头表中段的数量
2.寻找动态链接的`.interp`段，设置动态链接器的路径
3.根据ELF程序头表的描述，将ELF文件进行映射。如代码、数据、只读数据
4.初始化ELF进程环境。这一个不太理解
5.将系统调用的返回地址设置为ELF可执行文件的入口点，这个入口点取决于程序的链接方式，如果是静态链接就是elf文件程序头中的e_entry所指地址；如果是动态链接的elf可执行文件，入口就是动态链接器
以上执行完后，从内核态返回到用户态，从程序的入口地址开始执行。



