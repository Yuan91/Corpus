设计模式学习

# 目的

1.对于每一个设计思想，原则，模式有一个清晰的认识，知道它适应于什么样的业务场景

2.要用swift 实现课程中的实战项目

3.思考如何将这个设计思想/原则/模式，应用在项目中，并要对已有的项目做重构

4.在以后写代码的时候，要多加思考是否可以使用这种设计模式，已有的代码是否违背某种设计原则/思想/模式



**囫囵吐枣的学完，不如细致的学会重点的部分**


# 面向对象的基本特征及各解决什么问题
- [x] 封装
- [x] 继承
- [x] 多态
- [x] 抽象

是什么和解决了什么问题？语法层面需要哪些支持

1.封装
是什么：将实现细节封装到类/方法
解决了：数据安全、隐藏细节、职责单一等问题
语法支持：访问权限关键字

2.继承
是什么：解决了is-a问题，比如猫是一种哺乳动物
解决了：代码复用，一般/特殊的问题
语法继承：iOS中是“：”

3.多态
是什么：子类可以替换父类，具体实现替换协议类型
解决了：同一段代码，根据传入的对象不同，有不同的表现
语法支持: 继承，接口/实现

4.抽象
是什么：分离接口和实现，识别可能变化的部分
解决了：多态、开闭原则、代码扩展等问题
语法支持：protocol、interface、抽象类等

# 接口和抽象类
## 区别
抽象类可以包含属性和方法实现；接口只能定义方法，不能包含属性和方法实现。
抽象类不可以创建对象，只能被继承。
子类继承抽象类，必须重写里面的抽象方法。

## 选择
抽象类:关注于代码复用，并要求子类必须重写抽象方法。可惜iOS语法层面不支持，不然像哪些大的基类，都应该用抽象类代替(参考【子类过多override的缺陷】的实现，在一定程度上规避)。

接口:调用者只用关心接口，而不是具体实现。**将接口和实现分离。基于稳定的接口，灵活扩展不稳定/可能会变的实现，提高代码灵活性/扩展性**。

## 面向接口编程的重要技巧
封装具体的细节。某个实现才需要的方法，**即不那么通用的逻辑，不需要暴露在接口中**。

# 多用组合而不是继承
项目现状：
AirBrush中的FeatureBaseComponet作为基类，承担了太多的责任：
- 订阅
- 图片保存
- 设置UI
- 动画

大部分放到基类其实问题不大，但是有两个需要仔细设计下。订阅和多人脸
订阅：业务特点是，不是所有功能都需要订阅，目前虽然把这个放到了基类，但是还有一些限时免费的功能需要在子类处理，比如限时免费；付费的功能 每个都需要监听订阅通知，完成之后隐藏banner，这部分是重复的逻辑。 其实就很适合将订阅单独为插件，所有订阅逻辑 其实都是一样的，可以统一处理。

多人脸：业务特点是部分功能需要，且处理逻辑 基本一样。如果放到基类，就很容易造成基类过于庞大，且很多功能并不需要这部分逻辑。也很适合使用组合的方式。

## 继承的优缺点
优点：代码复用

缺点：
- 层次结构深的话代码不易理解；
- 过度耦合，修改父类，影响子类的行为；
- 容易写出一些四不像的代码，比如为了复用，将一些代码强行到父类。

## 什么样的场景适合使用组合，而不是继承：

首先继承的目的，是代码复用。所以一般也是代码复用的场景，才会考虑使用组合/继承。

**一些模块化的代码，只是部分子类需要，但不是所有子类都需要。
出于复用的目的，可以将这部分代码抽象为插件，而不是强行放到基类。**

举个例子，大部分鸟，会飞、会叫、会下单。但也有特例，比如鸵鸟/企鹅 不会飞；实际中鸟是这些特征的任意组合（类似上面AirBrush中的例子）。在代码中不可能将所有可能组合，每一种可能定义一个基类吧。所以就适合使用组合。

```
1.将每种能力，定义为协议
protocol Flyable {
 func fly()
}

protocol Tweetable {
    func tweet()
}

protocol EggLayable {
    func egg()
}

2.我们知道协议只是声明，并没有实现。所以我们添加默认实现

public class FlyAbility implements Flyable { 
@Override public void fly() { 
    //... 
    }
}

3.使用的时候

public class Ostrich implements Tweetable, EggLayable {//鸵鸟 

private TweetAbility tweetAbility = new TweetAbility(); //组合 private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 
    
    //... 省略其他属性和方法... 
    @Override public void tweet() { 
        tweetAbility.tweet(); // 委托 
    } 

    @Override public void layEgg() { 
        eggLayAbility.layEgg(); // 委托 
    }
}

```


## 组合的缺点
优点：**避免了四不像基类的设计，以更细的颗粒去复用代码**。
缺点：需要更多的接口和类，增加维护和理解成本。


# 设计原则
- [x] 单一职责
- [ ] 开闭原则
- [ ] 依赖倒置

# 设计模式

## 创建型
- [x]  单例
- [x] 工厂
- [x] 建造者
## 结构型
- [x] 代理
- [x] 装饰器
- [ ] 适配器
## 行为型
- [x] 观察者
- [x] 模板
- [x] 策略
- [x] 职责链
- [x] 迭代器





# 总结

## 设计模式的目的

设计模式解要干的事情就是**解耦**。

创建型模式解决的是对象创建的问题，将对象的创建和使用解耦；结构型模式解决的类和对象的组装问题，将不同的功能代码解耦；行为型模式解决的是类和对象之间的交互，将不同的行为解耦。

通过设计模式，**将一大坨代码拆分为职责单一的小类**，**让其满足开闭原则，高内聚低耦合，单一职责等特性**。以此达到提高代码可维护性的目的，当需要修改需求的时候，只修改一个单一职责的类或者干脆不用修改代码等，来减少代码维护、测试的成本，以及减少出错的可能性和影响范围。

应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性

## 如何理解面向接口(协议)编程

以前的理解： 通过swift的特性，给协议添加默认实现，依次来代替继承。

现在的理解：

- 协议是一种行为或者能力的抽象，它规定了一些属性或方法，遵循协议的类必须实现协议要求。当遵循协议的对象被当做参数传递到调用方时，调用者并不关心协议对象是如何实现这些要求的，它只管调用即可
- 协议是面向对象语言实现多态的重要手段。一个协议类型，可以代表多个实现协议的【子类型】，使得他们能够作为同一种类型的参数进行传递。进而使得代码满足单一职责、开闭原则等要求，减少在需求变动的时候，代码修改/测试的成本
- 大量的设计模式，都是用了面向接口/协议变成的特点，让代码满足单一职责/开闭原则。

## 如何写出可扩展的代码？

意识层面：应该具备抽象意识、封装意识、扩展意识

具体到业务层面，在写代码之前最好花一段时间想一想哪些未来是会发生变化的，哪些是不会变化的。**对于变化(不稳定)的部分抽象成稳定的接口提供给外部，当需求发生变化的，只需要基于相同的抽象接口扩展出一个新的实现，替换掉老的实现即可，这样外部的代码基本不需要改动。**

## 如何区分工厂模式和建造者模式
工厂模式：用来创建不同但是相关类型的对象（继承同一父类），由给定的参数决定创建哪种类型的对象
建造者模式：用来创建同一种类型的复杂对象，通过设置不同的参数，定制化创建不同的对象



策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。

