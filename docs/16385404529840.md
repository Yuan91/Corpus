调度策略

# 1.调度衡量的指标
系统吞吐量：表示单位时间内，CPU完成进程的数量。长作业占用较长时间的CPU资源时间，会降低吞吐量。
周转时间：一个进程运行时间和阻塞时间的总和，一个进程的周转时间越短越好。
等待时间：进程处于就绪队列的时间，注意不是阻塞的时间，等待时间越长用户越不满意
响应时间：从用户触发事件到第一次得到响应的时间
# 2.常见的调度算法
## 2.1先来先服务
顾明思议：每次调度时，取就绪队列中第一个进程。
分析：利于CPU密集型，不利于IO密集型，因为IO密集型只占用少量的CPU时间之后就进入的阻塞状态，当IO操作完成之后，会再次进入就绪队列，此时降低IO密集型进程的优先级
## 2.2短作业优先
定义：优先选择运行时间短的进程。疑问：怎么知道进程的运行时间？
分析：不利于长作业
## 2.3时间片轮转
无差异处理，每个进程获取20-50ms的时间片，但是不能很好处理优先级的问题
## 2.4多级反馈
该算法结合了时间片轮转和最高优先级算法：
● 定义多个优先级队列，越高优先级的时间片越短。(原因：高优先的进程能够提前执行，低优先级的因为等待时间长，而获取了更多的CPU时间；如果优先级进程未能在分配的时间内完成任务，则移入低优先级队列，虽然等待时间变长，但是执行执行时间也会更长)
● 反馈：如果新的进程加入高优先级的进程，则会立刻停止当前的进程，转去执行高优先级的进程。

# 3.进程的类型

IO密集型，频繁等待的进程。一般用于处理用户输入输出，因为IO设备一般速度比较低，会导致CPU空转。当触发IO事件后，会进入阻塞状态让出CPU时间。一般前台进程是IO密集型的
一个高优先级的IO密集型进程，由于大部分时间都处于等待状态，因此不容易操作其他进程饿死。回了避免进程饿死，操作系统通常会逐步提升，那么等待了很久的进程的优先级。在这样的手段下，只要一个进程等待足够长的时间，其优先级一定会提高到可以让他执行的程度。

CPU密集型：很少等待，长时间占用CPU

# 4.一个调度程序
以Linux 0.11为例说一下调度策略。
## 4.1 时间片的分配 
通过fork函数，完成父进程的copy
```
*p = *current;            //用来复制父进程的PCB数据信息，包括priority和counter
p->counter = p->priority;    //初始化counter
```
进程创建时counter和priority一样都是分配到的时间片

## 4.2时间片的消耗
硬件时钟每10ms中断一次，counter的值会减一，当counter为0时，会触发调度函数
```
void do_timer(...) {
    if ((--current->counter>0)) return;
    current->counter = 0;
    schedule();
}
```
## 4.3schedule
```
void schedule() {
while (1) {
    c = -1; next = 0; i = NR_TASKS; p = &task[NR_TASKS];
    //1.找到counter最大的就绪队列
    while (--i) {
        if (!*--p)    continue;
        if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
            //找到counter值最大的就绪态进程
            c = (*p)->counter, next = i;
    }                
    if (c) break;    //如果有counter值大于0的就绪态进程，则退出
    
    //2.重新分配：----
    //如果没有，即所有进程的时间片都用完了，则会重新分配
    for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
        //所有进程的counter值除以2衰减后再和priority值相加，产生新的时间片
          if (*p) (*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
}
switch_to(next);  //切换到next进程
}
```
counter的作用：
1.时间片：从4.1和4.2可以看出counter是承担有时间片作用的
2.动态调整优先级：阻塞的进程进入时间片重新分配的可能比较大，所以它的counter会动态增大，这有两个含义：①增加分配给它的时间；②counter变大，当进程进入就绪队列时，优先级也会相应增加

counter会一直无限增加吗？
不会，若进程无限等待，则counter = p + 1/2 * p + 1/4 * p + 1/8 * p + ...，无无限收敛于 2P