# 数据结构

## 链表



# 算法

## 递归

### 递归的基本思想

1.拆解问题

- 把规模大的问题拆解为同类型规模较小的问题
- 规模小的问题又可以拆解为同类型规模更小的问题
- 最终，规模小到可以直接求解

2.求解

- 由最小规模的问题，求解出规模较大的问题
- 由较大规模的问题，不断接触规模更大的问题
- 最终的出原问题的解

3.使用场景

链表和二叉树。因为这种数据结构本身就是一种递归结构

### 递归模板

1. 明确函数的功能

   > 先不要去思考里面的代码怎么写，先搞清楚这个函数本身是什么作用。

这句话很有意思，如一个反转链表的函数，它的功能就是对传入的链表进行反转。那么你对`node.next`调用该方法，即可反转该节点之后的链表，之后在处理好`node`和`node.next`的关系，即完成了链表的反转

```swift
func reverseLinkList(_ node: Node) -> Node? {
	//...
}
```

2. 明确源问题与子问题的关系

寻找出f(n) 和 f(n-1)的关系

3. 明确递归终止条件

基于此，递归的一般表达如下

```
func reverse(_ n: Int) -> Int {
	//终止条件
	 if(n <= 1) return n
	 
	 // 找出 f(n)和f(n-1)的关系，即reverse(n)= reverse(n-1)+n
	 // 同时开启下一个层级的递归
	 return n + reverse(n-1)
}
```

### 递归的复杂度

1. 空间复杂度 = 递归深度 * 每次调用所需的辅助空间

所谓递归深度，即递归的最大深度。这个是操作系统分配的一块连续的内存空间，在`递`的过程中会不断的push进去内容（参数/返回值等信息），在`归`的过程会视情况，进行push或pop。

因为操作系统给每一个进程分配的栈空间极为有限，所以如果递归没有终止条件会导致栈内存溢出（stactoverflow）

2.