# 进程与线程

# 为什么有了进程还需要线程
1.因为程序中往往有多种活动，某些活动可能随着时间的推移被阻塞，造成程序没有响应
2.进程切换时，耗费的资源比较多。因为进程管理的内容要多，如代码段，数据段，堆；这些内容线程是共享的，线程切换的时候，只要切换线程的栈空间就可以了。所以线程在数据共享方面效率要比进程高很多。
3.线程的创建和销毁比进程要快，大概要快10-100倍左右
4.多线程更能发挥多核CPU的性能
多个线程共享进程的地址空间和可用数据

# 线程都有些什么
1.栈空间：iOS中主线程1MB，子线程512KB.局部变量存储到这个里面
2.TLS:操作系统为线程提供的私有空间，一般认为只有有限空间

每个线程都有自己独立的调用栈和程序计数器，线程只使用运行必不可少的资源，如寄存器、栈、程序计数器。 详细解释：
- 调用栈 用于存储方法中的局部变量、参数和返回值，以及操作中间值
- 程序计数器： 存储下一条要执行的指令的地址 
这两个数据每个线程私有的，不同线程不共用。

# 逻辑线程 与 硬件线程
代码实现的是逻辑线程
硬件线程是执行指令而配套的硬件单元， 是逻辑线程执行的物质基础

# 可执行文件、进程、线程分别指什么？
可执行文件：一个静态的概念，如exe, elf, machO
进程：将可执行文件装载到内存 生成的实例
线程：进程中的执行流程

# 需要多线程的原因
- 并行计算
- 后台计算，将后台操作和主线程分开，不影响用户操作

# 线程相关重要概念

## 时间片
一个固定的时间单位，表示CPU分配给线程执行的时长。

## 上下文切换
不同线程切换时，操作系统会进行上下文切换：
- 保存当前线程的状态，pc寄存器的值 / 寄存器内容
- 加载下一个线程的数据，pc寄存器的值 / 寄存器内容

## 线程安全的方法/函数
多线程模型不安全的原因：
- 从进程的虚拟内存空间来看，线程有各自的栈空间，但是共享进程的__DATA Segment。
- 代码的执行不是原子的，所谓原子即 一条指令要么执行、要么不执行，不会有中间状态。

以最简单的 i++ 为例，要经过三个过程：
load: 将变量i的值 从内存加载到寄存器中
operator： 将i的值++
store: 将+1后的值 写回到内存中

在并发编程中，多个线程会同时操作一份数据，相互影响导致数据不安全/程序崩溃


那什么样的方法是线程安全的？
不访问共享数据， 共享数据包括：全量变量，static local变量， 类成员变量；只操作局部变量

## 线程阻塞的原因：
- 未获取到锁，进入忙等、睡眠的状态
- 执行了耗时操作
- 执行了系统调用，如网络IO, 磁盘IO

## 多线程中，我们要保护的是什么
共享数据，而非代码。

# 锁

## 互斥锁
未获取到锁的线程 会阻塞，持有锁的线程 释放锁之后，系统会重新调度一个线程执行， 被调度的线程 接触阻塞状态。

但是这样有一个弊端，多线程读的时候，其实数据不会有问题，但是线程之间依然要等待，这就需要读写锁了。

## 读写锁

写锁有3个状态：

- 已加读锁状态
- 已加写锁状态
- 未加锁状态

对应3个状态，读写锁有3个接口：加读锁，加写锁，解锁：

- 加读锁：如果读写锁处于已加写锁状态，则申请锁的线程阻塞；否则把锁设置为已加读锁状态并成功返回(即不阻塞线程，可以继续执行)。
- 加写锁：如果读写锁处于未加锁状态，则把锁设置为已加写锁状态并成功返回；否则阻塞。
- 解锁：把锁设置为未加锁状态后返回。

>读写锁也叫“共享互斥锁”，多个读线程可以并发访问同一资源，这对应共享的概念，而写线程是互斥的，写线程访问资源的时候，其他线程无论读写，都不可以进入临界代码区。

读写锁提升了线程的并行度，可以提升吞吐量。

## 自旋锁
> 线程在acquire自旋锁失败的时候，它不会主动让出CPU从而进入睡眠状态，而是会忙等,它会紧凑的执行测试和设置(Test-And-Set)指令，直到TAS成功，否则就一直占着CPU做TAS

## 如何选择锁

- 控制锁的粒度。大了会降低性能，线程多个额外的等待；小了 代码编写复杂。
- 合理控制锁的范围
- 自旋锁和互斥锁，如何选择？

自旋锁(忙等 不休眠)：临界区较短，未获取到锁的线程，只需等待很少的时间就能获取到锁。

 内核线程适合使用自选锁，因为内核线程可以关闭cpu调度 避免线程被调度；**内核线程调用的有些函数 不能被睡眠，只能使用自旋锁**

>而运行在用户态的应用程序，则推荐使用互斥锁等睡眠锁。因为运行在用户态应用程序，虽然很容易满足临界区代码简短，但持有锁时间依然可能很长。在分时共享的多任务系统上、当用户态线程的时间配额耗尽，或者在支持抢占式的系统上、有更高优先级的任务就绪，那么持有自旋锁的线程就会被系统调度走，这样持有锁的过程就有可能很长，而忙等自旋锁的其他线程就会白白消耗CPU资源，这样的话，就跟自旋锁的理念相背。


# lock-free
不使用锁，但是能达到线程安全的目标，底层是cas（原子指令）实现的。 
 




# 内核级线程：
用户级线程创建，内核是不知道有这个线程的，在阻塞的时候，很有可能切换到其他进程

内核栈中的源ss， sp, pc， cs都是指的什么
内核态是什么

# 为什么要有用户态和内核态的切换

多核(公用一套MMU)要想充分发挥作用，必须要有核心级线程。多线程只有到内核（态）里，才能把内存分配到多个核上。
核(CPU)是由操作系统分配的，用户态的线程，操作系统是不知道的，也就没有办法给他分配(硬件)资源

进入内核的唯一方法：中断，包括硬件中断和时钟中断。fork创建线程的系统调用，是系统调用，会引用中断。

最开始在用户栈，接受到中断(int)指令，到内核栈。此时存储用户栈的ss, sp, pc, cs
ss: 用户栈的起始地址
sp: 用户栈的偏移地址(栈顶？)
pc: 程序正在执行指令的下一条指令地址
cs:存放代码段的起始地址

iret 中断返回，将内核栈保存的寄存器信息，恢复到用户栈，让用户程序继续执行.
ps:一般是返回到到另外一个线程的用户态，因为前一个触发中断的线程，可能会阻塞

# 内核级线程的实现：
进程=资源+执行序列，而进程必须要进入内核，要就是必须要有内核级线程



参考文档：
https://mp.weixin.qq.com/s/a9BUf6N93uOw8JSAxza7cg
