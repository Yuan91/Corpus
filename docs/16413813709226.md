# 《程序员的自我修养--第六章--装载》

## 关于虚拟地址空间的理解
1.什么是虚拟地址空间？
以Linux 32为操作系统为例，一个进程的虚拟地址空间如下：
1G 内核空间 + 3G 用户空间。其中用户空间从低地址到高地址依次是：代码段，数据段，堆区，共享库，栈区。
![linux 32位进程虚拟地址空间](media/16413813709226/linux%2032%E4%BD%8D%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

2.为什么要使用虚拟地址空间？
- 地址隔离：每个进程都拥有自己独立的虚拟空间，避免程序直接访问内存，避免程序被其他程序修改。
- 内存使用效率：结合内存分页，提高内存使用效率。相对于之前整段程序加载（静态加载）进内存而言
- 程序运行地址确定：以静态链接为例，在链接之后，程序中代码和数据的地址都确定了，只需要在启动时装载到内存即可，避免了数据和指令的重定位。当然还是需要mmu映射到具体的物理内存

## 进程的装载方式
动态装入的原理：程序是有局部性原理的，即程序运行时，一段时间内只有一部分代码经常被用到。所以我们可以将不常用的部分放到磁盘里，用到的时候，在装入内存。

X位操作系统：ALU一次运算的位数，而不是地址总线的位数。

### 覆盖装入 Overlay
相关之间没有业务关联的模块可以覆盖，但是需要程序员手动指定依赖关系。
缺点：
1.需要手动指定依赖关系，繁琐/容易出错
2.粒度大，以模块为单位。进而造成换入换出的效率低，程序执行慢

### 页映射
页映射是虚拟存储的一部分，它将内存和所有磁盘中的数据和指令按照页为单位划分，以后装载和换入换出的单位就是页。一般页是4K大小。

可执行文件中的页可能被加载到物理内存中任意页，如果程序直接使用物理地址进行操作，那么每次装入时都需要进行重定位。所以还是要使用虚拟地址！

## 装载

### 装载的过程
1.创建虚拟地址空间。虚拟地址空间并不存在，这一步其实是建立虚拟地址到物理地址的映射，创建这个映射所需要的数据。
2.建立虚拟地址和可执行文件的映射。当发生缺少错误时，将数据/指令换入内存时，需要知道缺少的那个页(虚拟地址)在可执行文件中的位置。它记录在一个叫VMA，Virtual Memory Address的数据结构中
3.将CPU指令寄存器设置为可执行文件的入口，将控制权交给用户程序。

### page fault 处理流程
1.发现访问页不在内存，触发page fault,将控制权交给操作系统。
2.在物理内存中分配一个页，根据缺少页的VMA，找到它在可执行文件中的位置，将它读入内存，并建立虚拟地址和物理地址的映射
3.将控制权交给进程，进程从页错误的地方**重新**执行。

