# 网络总结
## https
### 作用
- 数据加密(tls握手阶段非对称加密，tls record阶段对称加密)
- 身份认证(证书签名计算对比，证书信任链)
- 防止篡改（第三次和第四次握手发送的Encrypted Handshake Message消息，用于验证握手消息是否有被中途篡改过）
### 流程
WireShark抓包显示https的实现需要**4次TLS握手**，即2个RTT

![截屏2021-08-14 下午1.55.02.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91a3158a917f40c78f000291e15a506b~tplv-k3u1fbpfcp-watermark.image)
#### TLS 第一次握手
发送ClientHello 报文：Random_C，TLS协议版本，支持的加密套件列表

注：加密套件包括：会话密码交换时的非对称加密算法，以及http报文加密的算法，摘要算法(用于消息认证和产生随机数)
#### TLS 第二次握手
发送三个内容
1.发送ServerHello报文：Random_S，TLS协议版本，选择的加密套件

2.Server证书

3.ServerHelloDone

#### Client证书验证
首先对证书进行校验。具体：**操作系统或浏览器内置CA机构的公钥**，通过它对证书的数字签名(即证书生成时有CA私钥对证书信息生成的摘要)解密，同时本地通过对获取到证书信息通过同样的hash算法计算出一个签名，判断两者是否一致。除了签名计算外，还有证书信任链的验证

#### TLS 第三次握手
1.客户端生成PreMaster，它用来生成真正的会话秘钥=RandomC + RandomS + PreMasterKey.PreMaster 通过证书里的公钥加密

该PreMaser通过【Client Key Exchange】发送给Server,随后发送【Change Cipher Key Exchange】告知服务端改用对称加密

2.Client生成所有握手信息的摘要，通过【Encrypted Handshake Message(Finishd)】发送给Server。用途：把之前所有发送的数据做个摘要，再用会话密钥(master secret)加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有 被中途篡改过。

#### TLS 第四次握手
通过私钥解密出PreMaster,同样发送【Change Cipher Key Exchange】和【Encrypted Handshake Message(Finishd)】两个报文给Client

至此TLS Handshake Protocol结束，后面通过协商好的会话秘钥，进行对称加密的request-response的报文传输

如果面试，记得说一下使用https基本可以保证数据的安全，但是对于抓包工作来说还是明文传输，需要做一下处理。把问题引导自己的节奏上来

#### 证书的内容
服务端自己的公钥，域名，有效期，签发机构，签名以及签名算法

#### 加密套件的内容
1. 包含秘钥交换算法(RSA,ECDH)
2. 证书签名解密算法（证书中的摘要，是通过CA公钥加密过的，因此解密之后，才可以用来对比）
3. 会话阶段 加密算法
4. tls 握手第三 第四次生成摘要的算法

### 整个https握手过程中 用到的公钥和私钥
用到两套公钥和私钥：
- CA的公钥和私钥
- 服务端的公钥和私钥

1.先说下证书包含什么？
服务端的公钥、主体信息如域名、机构、到期时间等，证书签名。
申请证书的时候，服务端先生成私钥，在生成CSR. 
CSR包含以下信息
	•	服务端公钥
	•	域名（Common Name）
	•	组织信息
	•	国家和地区信息
	•	可选的扩展字段（如 SAN）。
	
2.CA机构的作用
校验CSR，对证书信息进行哈希生成摘要，使用**CA私钥对摘要加密生成签名**
CA的公钥被内置到操作系统和浏览器中，当client收到server的证书时 对其进行校验，其中签名的校验如下：
- 使用**CA公钥解密签名**得到hash1
- 使用同样的摘要算法对证书进行哈希得到hash2
- 当hash1合hash2相同 即签名通过

3.服务端公、私钥的作用
- 公钥是证书的一部分，会被发送给客户端
- 客户端使用公钥，对pre master key加密 发送给服务端；服务端使用私钥解密出pre master key。在服务端和客户端之间使用非对称加密算法交换密钥。
- 生成共享密钥：使用client random、server random、pre master key基于同样的加密算法生成共享密钥，后续请求和响应报文的加密的都是用这个密码，后续的加密也是对称的

## 非对称加密

非对称加密是一种加密技术，它使用一对密钥：公钥（Public Key）和私钥（Private Key）。这对密钥密切相关，但有以下特性：
	1.	公钥和私钥成对存在：
	•	公钥用于加密，私钥用于解密。
	•	或者私钥用于加密，公钥用于解密（常见于数字签名）。
	2.	单向性：
	•	使用公钥加密的数据只能用私钥解密。 
	•	使用私钥加密的数据只能用公钥解密。
	即公对公，私对私 都是不行的
	
	主要功能

1. 数据加密：
	•	公钥加密，私钥解密：
当发送方希望保证信息只能被接收方读取时，发送方用接收方的公钥对数据加密，接收方用自己的私钥解密。

可以反过来吗？私钥加密 公钥解密。
技术上可行，业务上不行。因为公钥是公开的，这样就会造成任何用于公钥的人 都能解密数据


2. 数字签名：
	•	私钥签名，公钥验证：
当发送方希望证明消息的真实性和完整性时，发送方用自己的私钥对消息签名，接收方用发送方的公钥验证签名。

## https抓包相关

### 抓包原理
中间人攻击，以Charles为例，抓包之前需要先安装Charles根证书并信任，之后的request-response都会经过Charles中转：截获客户端发送给服务端的请求，伪装成客户端与服务端通信；同时将服务端返回的内容转发给客户端

### 如何防止抓包
#### 检查代理
抓包可以认为是一种网络代理，app内检查是否有使用网络代理，然后做出相应的处理。
但是有弊端就是，如果用户开启VPN会被误判

#### SSL Pinning(证书绑定)
将证书内置在app中，根据需要设置验证模式，一般有两种可选：验证公钥和证书字段逐一验证。逐一验证安全性更高，要求所有字段一样，但是会有问题就是证书需要定期更换，如果未更换到期之后，会出现https请求无法连接的问题

另外，内嵌证书都会遇到的问题就是app被砸克替换证书，然后重签名安装。
针对这种问题，一般需要对app做逆向相关的防护，如重签名检测，文件hash计算等

#### 关于证书验证
app内如果实现didReceiveChallenge方法，那么会优先走app内的证书验证，而不是操作系统验证。

验证类型有多中，我们一般处理的是对服务端的身份认证即单向认证(NSURLAuthenticationMethodServerTrust),其他几种都是双向认证。

参考文章：https://easeapi.com/blog/blog/137-ssl-pinning.html
https://segmentfault.com/a/1190000021559557


