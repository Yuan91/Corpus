swift 与 oc异同
 

# 一、对象

swift的类：从NSObject派生；没有指定父类，默认从SwiftObject派生

swift对象内存布局和oc相似，但并不完全一样。对象最开始有一个isa指向类的描述信息，该描述信息中包含一个虚函数表，为方法调用服务

Swift对象创建：堆内存分配，调用init构造函数。不像oc 明确的分为alloc和init两个步骤。在编译时给每个类生成构造和析构函数。比如

```
class CA {
   init(_ a:Int){}
}

//编译生成的对象内存分配创建和初始化函数代码
CA * XXX.CA.__allocating_init(swift_class  classCA,  int a)
{
    CA *obj = swift_allocObject(classCA);  //分配内存。
    obj->init(a);  //调用初始化函数。
}

//编译时还会生成对象的析构和内存销毁函数代码
XXX.CA.__deallocating_deinit(CA *obj)
{
   obj->deinit()  //调用析构函数
   swift_deallocClassInstance(obj);  //销毁对象分配的内存。
}

```

swift对象的生命周期也是和oc一样通过引用计数管理的

# 二、swift类中方法的调用
分三种：OC类的派生类并且重写了基类的方法、extension中的定义的方法、类中定义的常规方法

oc派生类，调用/重写 原oc方法，则还是走原来的objc_msgSend方法
oc派生类，新增自定义方法，使用虚函数表派发。虚函数表存在类对象中。

extension中定义的方法，在编译时决定，方法调用中的函数地址将会以硬编码的形式存在。在extension中无法再运行时做任何替换和改变，且方法函数的符号信息，不会保存到类的描述信息中。这解释了Swift派生类无法重写一个基类extension定义的方法

extension中是可以重写OC基类的方法，但是不能重写Swift类中的定义的方法？
为什么不太明白

类中定义的常规方法：通过虚函数表派发。swift示例中有一个isa成员变量，它指向类的描述信息，其中有一个虚函数表，每个条目保存着一个方法的函数地址。每一个对象方法的调用，在编译时就会转为从虚函数去对应偏移位置的函数地址来实现简介的函数调用。

swift每个类对象，都有改类所有的实例方法，加入子类重写了父类的方法，那么会出现子类和父类 同样索引位置的，保存不同的函数地址，这主要是为了实现多态。

# 三、swift类中成员变量的访问
Swift和oc的共同之处：都有isa，实例变量排在它后面

oc特有：为成员变量生成一张表，记录着每个成员变量在对象内存中的偏移量，访问属性时就是通过这个偏移量，拿到对应成员变量；这个偏移量值的获取在编译链接时 硬编码完成

swift: 同oc一样生成set和get，但不会生成偏移量信息表。但是还有要通过偏移量来访问成员变量

# 四、结构体中的方法
结构体无isa，无类的描述信息。因此方法调用是编译时硬编码，与extension类似

# 五、类方法及全局函数
在编译链接时刻硬编码为函数地址调用来处理的

# 六、oc调用swift
@objc 方法在底层的逻辑：在编译时会生成两个函数，一个供swift本体调用；另一个跳板函数 是供oc语言调用的。

```
//本体函数foo的实现，记录在vtable中
void foo(){
}

 //跳板函数的实现 ，记录在oc类的方法列表
void trampoline_foo(id self, SEL _cmd){ 
asm("mov x20, x0"); 
self->isa->vtable[0](); //这里调用本体函数foo 
}
```

# 七、编译优化的方法调用
1. 最主要的 弱化通过虚函数表来间接调用方法的实现，而是大量改用了一些内联的方法

内联函数：被内联的方法，在调用的时候，不是通过虚函数表，而是直接将内联函数的指令拷贝过来。没有函数调用的跳转指令，而是直接执行方法定义中的指令
好处：加快执行速度
坏处：增加包体积

举例：
```
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

let result = add(10, 20)  // 这里需要函数调用
let result = 10 + 20  // 直接替换，省去函数调用
```

2. 多态的优化
```
//classCB继承自classCA
void testfunc(CA *obj)
{
    //这里并不是通过虚表来进行间接调用而实现多态，而是直接硬编码通过类型判断来进行函数调用从而实现多态的能力。
    asm("mov x20, obj");
    if (obj->isa == &classCA)
         fooForA();
    else if (obj->isa == &classCB)
        fooForB();
}


```

# 八、其他
final 标记的方法会变成直接派发，提高性能，代价是损失了动态性、不支持继承


参考链接：https://juejin.cn/post/6844903889523884039#heading-6