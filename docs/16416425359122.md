# 《程序员的自我修养--第十章--内存》

## 程序的内存分布
![linux 2.4进程虚拟空间](media/16416425359122/linux%202.4%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4.png)
 
 动态链接库映射区：从0x40000000开始的一段空间，用来映射共享库。
 
 ## 栈与调用管理
 
 ### 什么是栈
 栈是先进后出的一个容器。
 
 ### 栈的特性
 1.栈总是向下生长
 2.栈顶指针由esp寄存器保存，压栈使得栈顶指针减小，出栈使得栈顶直增增大。同理减小esp的值相当于在栈上开辟空间，增大esp的值相当于栈上空间的回收。
 
 ps: swift值类型存储在栈上，释放是很快的，有这方面的原因(直接增大esp的值)，而类因为在堆上有引用计数需要管理，所以要慢一点。
 
 ps2:相对esp, ebp 指向函数活动记录的一个固定值。
 
3.栈保存了函数调用所需的信息，这常常被称为栈帧，栈帧一般保存如下信息：
- 函数的返回地址和参数
- 临时变量：函数的非静态变量和编译器生成的其他临时变量。
- 保存上下文：函数调用前后需要保持不变的寄存器。

为什么寄存器的值会保存在栈中？
**因为寄存器个数有限，它可能保存了之前计算的中间值，因此在函数调用时，可能会出现寄存器不够 or 避免它们的值被修改，因此需要把它的内容保存在栈中。**
 
 ### 栈的活动记录
 ![栈帧](media/16416425359122/%E6%A0%88%E5%B8%A7.png)

esp随着函数的执行不会变化，ebp则**不随这个函数**的执行而变化，可以用它定位活动记录中的值，如在ebp之前首先是这个函数的返回地址它的地址是ebp-4，在往上时入栈的参数，分别是ebp-8, ebp-12等；而ebp则是存储调用该函数前ebp的值，这样函数返回时，ebp可以通过读取这个值恢复到之前。

### 函数调用约定
函数调用方和函数本身，应当对于函数是如何调用有一个明确的约定，只有双方都遵循这个约定，函数才能正确的执行。这就叫做函数的调用约定

举例：①函数的参数，可以通过栈传递，也可以通过寄存器，如何调用双方处理方案不一致，则参数的保存和获取会出现问题，函数不能正确的执行；②参数的保存顺序，是从左到右还是反之

一般的调用惯例保活一下几部分：
1.参数的传递，常见的是通过栈传递；如果想要高性能也可以通过寄存器
2.栈的维护方法，函数调用之后，需要弹栈。约定好弹栈的工作由哪一方执行

## 堆

为什么需要堆？
栈上的数据出栈时，会被释放掉；而全局变量没有办法动态产生，只能在编译的时候定义。
因此需要一块堆空间，来存储程序运行时产生的数据。malloc 的空间，在堆上

malloc是如何实现的？
每次申请或者释放堆空间的时候，都要通过系统调用，而系统调用的开销很大。
如果这样的操作比较频繁的，是会对程序的性能造成影响的。
因此一般的做法，程序预先向操作系统申请一块比较大的空间，程序自己来管理。







 
 
 