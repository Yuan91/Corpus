# 《Objective-C 高级编程--GCD》

## 队列
### 概述
1.`serial queue`： 在一个线程中执行完所有的任务。执行顺序：一次只能执行一个任务，一个执行完再执行下一个。系统对于一个`serial queue`就只生成并使用一个线程。
2.`concurrent dispatch queue`: 可能会在多个线程中执行完任务。内核根据队列中任务数、CPU核心数、CPU负载等系统状况，创建所需的线程；且任务执行完之后，会自动释放不需要的线程。执行顺序：提交任务到多个线程并行执行，因此执行顺序并不固定

## API 
### dispatch_set_target_queue(A, B)
1.修改队列的优先级，将A的优先级改为和B一样
2.修改执行层次，将A的执行方式(串、并)改为和B一样

### dispatch_after
是x秒后，将任务提交到队列。队列中可能会有其他任务，因此并不是严格的x秒后就立即执行；另外，若是提交到Main Dispatch Queue，则还要加上runloop执行的间隔

### dispatch_sync
阻塞当前线程，直到队列中的任务执行完。

### dispatch_apply
```
dispatch_queue_t  queue = aGlobalQueue;
dispatch_apply(10,  queue, ^(size_t size){
    NSLog(@"%zu", index);
});
执行10次之后，才会返回
```

### dispatch_suspend/resume
dispatch_suspend 会挂起指定的queue，这个操作对已经执行的任务没有影响。挂起后，追加到queue中但尚未执行的处理，在此后会停止执行。**那执行中的任务呢？**

### 待学习
目前对于gcd的认知仅限于知道队列和同步异步的使用，但是对于其工作原理，基本一无所知，下面列出一些关键要学习的点：
1.按照书本说的：每一个串行队列都会创建一个线程；并发队列，会根据CPU核心数、CPU负载、任务数等创建线程。那么这一块具体代码是怎样的？同时任务提交之后，是在创建的线程执行吗？
2.gcd是如何创建线程的？在什么情况下(跟队列还是async/sync有关)会创建线程？
3.追加到Main Dispatch Queue的任务，在主线程的runloop中执行。这个该如何理解？主队列和主线程有什么区别
4.gcd中的任务是怎么被执行的
5.并行队列任务是怎么调度的
6.gcd中死锁的本质
7.内核级线程和workqueue？
8.dispatch_sync 是如何阻塞当前线程的
9.dispatch_semaphre是如何操作线程控制并发的
10.`GCD的线程管理在系统级，即iOS和OS X的核心级上实现`。该如何理解？内核级线程和用户线程有什么区别

https://github.com/bestswifter/blog/blob/master/articles/objc-gcd.md
https://xiaozhuanlan.com/topic/7193856240
### 源码阅读
#### dispatch_once

#### dispatch_queue
`do_vtable`:一个结构体，类似如下结构
```
unsigned long const do_type;    \                           // 数据的具体类型
const char *const do_kind; \                                // 数据的类型描述字符串
size_t (*const do_debug)(struct x *, char *, size_t);   \   // 用来获取调试时需要的变量信息
struct dispatch_queue_s *(*const do_invoke)(struct x *);\   // 唤醒队列的方法，全局队列和主队列此项为NULL
bool (*const do_probe)(struct x *); \                       // 用于检测传入对象中的一些值是否满足条件
void (*const do_dispose)(struct x *)                        // 销毁队列的方法，通常内部会调用 这个对象的 finalizer 函数


static const struct dispatch_queue_vtable_s _dispatch_queue_vtable = {
    .do_type = DISPATCH_QUEUE_TYPE,
    .do_kind = "queue",
    .do_dispose = _dispatch_queue_dispose,
    .do_invoke = (void *)dummy_function_r0,
    .do_probe = (void *)dummy_function_r0,
    .do_debug = dispatch_queue_debug,
};
```
`dq_width`: 并发数。为1说明是串行队列，全局队列时UINT32_MAX
`dq_serialnum`: 序列号，仅仅是一个数字，无特殊含义
`dq_running`: 0是空闲，表示运行中的任务数？
`do_targetq`: 目标队列。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。 **涉及到队列的层次结构**

https://www.dazhuanlan.com/zzuwangfeng/topics/1283497

源码在哪里？
>如果在自定义队列时，传递了attr参数，那么表示支持overcommit，带有overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载。

1.添加任务时，如果队列为空，则立刻唤醒。唤醒分主队列(`_dispatch_queue_wakeup_main`)和全局并发队列`_dispatch_queue_wakeup_global`

唤醒的过程中，会根据内核的状态(`qc->dgq_thread_pool_size`)判断是否要生成线程，如果是overcommit优先级的队列，workqueue则始终生成线程。

2.如果不为空，则插入到队列尾部。

3.队列中的任务执行之后，会等待65s，如果没有接受到信号量则释放线程；如果收到唤醒型号量，则继续执行。为什么是65s？大概是避免重复创建线程吧。同时这里的信号量正式前面唤醒队列发出的信号量

4._dispatch_worker_thread2
全局队列唤醒之后，最终都走到`_dispatch_worker_thread2`这个函数。它里面不停的从dispatch_queue中取出任务执行，如果没有任务就休眠
```
while ((item = fastpath(_dispatch_queue_concurrent_drain_one(dq)))) {
        // 用来对取出的内容进行处理(如果是任务，则执行任务)
        _dispatch_continuation_pop(item);
    }
```

### dispatch_sync
dispatch_sync同步方法的实现相对来说更简单，只需要将任务压入响应的队列，并用信号量做等待
#### 在串行队列中，添加任务
调用 dispatch_barrier_sync_f:
```
void dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func)
{
    // 保存当前线程的TSD：key为dispatch_queue_key
    dispatch_queue_t old_dq = _dispatch_thread_getspecific(dispatch_queue_key);

    // 1) ensure that this thread hasn't enqueued anything ahead of this call
    // 2) the queue is not suspended
    // 3) the queue is not weird
    if (slowpath(dq->dq_items_tail)
            || slowpath(DISPATCH_OBJECT_SUSPENDED(dq))
            || slowpath(!_dispatch_queue_trylock(dq))) {
        return _dispatch_barrier_sync_f_slow(dq, ctxt, func);
    }

    // 核心逻辑，将当前线程的目标dispatch_queue_key设置为dq，然后执行block，之后再恢复之前的old_dq
    _dispatch_thread_setspecific(dispatch_queue_key, dq);
    func(ctxt);
    _dispatch_workitem_inc();
    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);
    _dispatch_queue_unlock(dq);
}
```

#### 并行
如果向一个并发队列中压入同步任务，如果队列不为空，或者挂起，或者有正在执行的任务，则调用_dispatch_sync_f_slow，进行信号量等待，等待这个队列中其他任务的完成；否则直接调用_dispatch_wakeup 唤醒队列执行任务

在gcd中任务的完成是如何体现的？
如果是串行，执行完就行了；并行的，执行完，发送一个信号量？


gcd唤醒主线程的代码
```
void _dispatch_queue_wakeup_main(void)
{
    kern_return_t kr;
    
    // dispatch_once_f保证只初始化1次
    dispatch_once_f(&_dispatch_main_q_port_pred, NULL, _dispatch_main_q_port_init);
    
    // 唤醒主线程（核心逻辑在这里，可惜未开源）
    kr = _dispatch_send_wakeup_main_thread(main_q_port, 0);

    switch (kr) {
    case MACH_SEND_TIMEOUT:
    case MACH_SEND_TIMED_OUT:
    case MACH_SEND_INVALID_DEST:
        break;
    default:
        dispatch_assume_zero(kr);
        break;
    }

    _dispatch_safe_fork = false;
}
```

#### dispatch_async


## 其他
1.tsd: 同一个线程内不同函数间的数据访问机制，在不同的线程中，虽然他们的key相同，但是获取到的数据是不同的
2.fastpath && slowpath
编译优化
```
#define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))
#define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))
```
fastpath(x): 依赖返回x，只要告诉编译器x一般不会0，从而优化程序执行分支语句的效率；
slowpath(x): 依赖返回x，只要告诉编译器x很可能0，从而优化程序执行分支语句的效率；
