iOS多线程 与 runloop

# 基础
## 线程与进程的区别
- 根本区别：进程是操作系统分配资源的基本单位，线程是任务调度和执行的基本单位。相应的，一个线程共享进程的内存空间和资源，而进程之间的资源则相互独立；同时进程必须要有一个线程来执行任务
- 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
- 执行过程: 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中
## 多线程的优缺点
有点：适当提升程序执行的效率

缺点: 每一个线程都要分配512KB的内存，线程越多分配空间越大；且线程切换时需要更多的资源存储上下文信息






## synchronize的实现原理
它是递归锁，代码块的开始和结束分别调用`objc_sync_enter`和 `objc_sync_exit`。
具体参考：
https://juejin.cn/post/6844904167010467854#heading-17

# 卡顿检测
## 如何检测
给主线程添加runloop的observer，然后创建子线程持续的观察主线程的状态，主要是beforeSource和afterWaiting，当处在这两个状态超过一定的时间，即认为是卡顿
## 为什么选择这两个状态
afterwaiting的原因，runloop被唤醒之后会发出这个通知，然后开始处理唤醒事件，如timer/点击事件/gcd事件，处理完之后变成beforetimer，而如果检测到一直出在afterwaiting，那就说明处理了耗时事件

beforesource也是同理，通知发出之后开始处理事件，如果长时间停留在该状态也说明发生了耗时事件
## 阈值如何选择
主程序 Runloop 超时的阈值是 2 秒。子线程的检查周期是 1 秒，每隔 1 秒子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照

## 优化
1. 如果CPU过高，如占用超过80%也可认为是卡顿
2. 卡顿时捕获到的日志，先不写入文件。如果下一次是不同的卡顿日志在写入；如果是相同的，已斐波那契数列递增检查的事件。这样可以避免重复写入，以及写入时的资源浪费
3. 上报优化，分析卡顿日志大小，即便较小，但是用户量较大，那对服务器来说也是很大的压力，最好是抽样上报