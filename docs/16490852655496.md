哈希表
# 解决hash冲突的四种方法
1. 开放定址法：发生冲突的时候，就继续向下探测。
2. 拉链法：数组中存储链表
3. 在哈希法：构造多个hash函数，如果发生冲突，就使用其他hash函数，直到不冲突为止
4. 建立公共溢出缓冲区，专门用来存储冲突的元素。

需要说明的是：
**哈希并不是简单的存储value，而是存储key和value的一个包装类。否则，冲突的时候根本不知道key-value是如何对应的**
冲突的概念：不同的key，通过一个哈希函数计算出来的索引是一样的

# 不同方法的对比
## 拉链法和开放定址法
优缺点：
先说下，在系统中的应用场景，weak指针的hash表使用的开放定址法，而@synchronize使用的是拉链法。weak指针一般比较少，不需要哈希表再次扩容；而@synchronize维护一个全局的哈希表，存储的对象比较多，使用链表的话避免扩容

**优缺点衡量的重要标准：
存储数量是否可以确定；
是否需要扩容；扩容之后，是否会造成容量的浪费；扩容带来的性能损耗
删除操作**

## 开放定址：
优点：如果数量可以预见，那么使用起来很好
缺点：
1.到容量之后，需要扩容和重哈希
2.扩容之后，可能会造成容量浪费
3.删除操作，如果a和b哈希冲突且a在b前，**如果要删除a是置位nil的话，那么会造成无法访问b**，所以删除的操作其实是要需要标记删除的，而不能直接删除，这就需要额外的空间和操作。

## 拉链法：
优点：
1.不需要扩容，对于数量不定的场景很适合；
2.删除操作，直接删除链表节点
缺点：
1.增加了指针，占用了额外的内存
2.不好序列化

## 再哈希法
不容易聚集，增加了计算时间

## 建立公共溢出区
冲突较少时性能较好，冲突多了就耗时

参考：https://foodiewang.site/post/java-jie-jue-hash-chong-tu-de-si-chong-fang-shi/

# 常见的哈希算法
md5, sha