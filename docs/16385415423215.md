Runloop

# 卡顿检测
## 如何检测
给主线程添加runloop的observer，然后创建子线程持续的观察主线程的状态，主要是beforeSource和afterWaiting，当处在这两个状态超过一定的时间，即认为是卡顿
## 为什么选择这两个状态
afterwaiting的原因，runloop被唤醒之后会发出这个通知，然后开始处理唤醒事件，如timer/点击事件/gcd事件，处理完之后变成beforetimer，而如果检测到一直出在afterwaiting，那就说明处理了耗时事件

beforesource也是同理，通知发出之后开始处理事件，如果长时间停留在该状态也说明发生了耗时事件
## 阈值如何选择
主程序 Runloop 超时的阈值是 2 秒。子线程的检查周期是 1 秒，每隔 1 秒子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照

## 优化
1. 如果CPU过高，如占用超过80%也可认为是卡顿
2. 卡顿时捕获到的日志，先不写入文件。如果下一次是不同的卡顿日志在写入；如果是相同的，已斐波那契数列递增检查的事件。这样可以避免重复写入，以及写入时的资源浪费
3. 上报优化，分析卡顿日志大小，即便较小，但是用户量较大，那对服务器来说也是很大的压力，最好是抽样上报