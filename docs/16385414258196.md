Block研究

# 0 Block是什么
Block在底层是一个结构体，包含isa指针、**持有一个funcPtr指向代码块转换后的方法地址**。
这句话其实解释了很多：
1.为什么默认情况下block在栈上？因为block是一个结构体类型的局部变量，而局部变量正是在栈上
2.为什么block内无法修改局部变量，但可以修改全局变量？因为block内代码被编译为一个方法，和访问的局部变量**不在同一个作用域**
3.为什么block内不会捕获全局变量？原因同上，因为是全局变量，可以直接访问


# 1 概念性总结
## 1.1 Block的类型
自动变量维基百科定义：进入作用域系统为其分配空间，离开作用域释放空间的一类变量。**等同于局部变量**

以下不管ARC还是MRC都成立
| 类型   | 定义                   | copy之后          | 捕获对象的引用计数 | 存储区域 | 内存回收策略 |
|--------|------------------------|-------------------|----------|-------|----|
| global | 没有捕获自动变量，或者只访问了全局变量、全局静态变量 | 无效果 | 不捕获|           数据区 | - |
| stack  | 捕获了自动变量   | block被copy到堆上 | 不捕获对象,更不会增加引用计数 | 栈区 | 超过作用域系统回收|
| malloc | stack 类型copy之后     | block引用计数加一  | 对于捕获的strong类型对象会retain，即copy一份 | 堆区 | 没有对象持有Block时，调用它的dispose函数释放 |

## 1.2 捕获变量分析

| 变量类型              | 捕获类型 |
|-|-|
| 全部变量、全局静态变量 | 不捕获   |
| 局部静态变量          | 指针捕获 |
| 局部基本数据类型              | 值捕获       |
| 局部对象              | 指针捕获       |

问：为什么 auto 局部变量捕获的是值，而 static 变量捕获的是指针？
因为block 可能会延迟调用，即超出变量的作用域，而auto变量超出作用域即销毁，所以要捕获它的值；而static则是一直存在的，那么只捕获一个指针即可

# 2 Block 中的Copy
## 2.1 ARC下copy的时机：
1.手动调用copy\
2.Block是函数的返回值\
3.Block被强引用，Block被赋值给__strong类型变量\
4.Cocoa框架中入参含有usingBlcok；CGD中的API

## 2.2 block发生copy会做的事：
1.首先将block copy，并移动的堆上
2.对于捕获的对象，如果是strong指针描述的，会对齐进行retain操作，引用计数加一;同样在block释放的时候，会相应的进行release操作

## 2.3 Block为什么使用copy?
常规解释：
不进行copy，那么block在栈上，随着作用域结束block就被释放，不能保证正常调用。因此需要将block copy到堆上
第二层含义：
copy之后，block对捕获的对象进行retain操作延长了它的生命周期，防止在block调用的时候被释放掉

# 3 __block 关键字

## 3.0 __block作用
解决block无法修改局部变量的问题。
为什么呢？
将局部变量转换为一个结构体，这个结构体持有这个变量(当时对象类型时，持有引用)；可以通过这个结构体修改变量

## 3.1 __block变量的拷贝
1.当block从栈拷贝到堆时，如果它持有__block类型的变量，那么会对__block一并拷贝
2.如果多个block持有同一个__block变量，那么后面的拷贝，意味着__block变量引用计数的增加
3.只有在所有block对__block的引用都释放，这个变量才会释放
以上思考模式和引用计数一样

## 3.2 __block的原理

**将描述的对象生成为一个结构体**，block内捕获的变量会变为结构体类型的同名变量，从而扩展的变量的作用域
```
//block_obj变量变成了结构体
struct __Block_byref_block_obj_0 {
  void *__isa;
__Block_byref_block_obj_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 id block_obj; //block_obj变量的
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  id obj;
  __Block_byref_block_obj_0 *block_obj; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _obj, __Block_byref_block_obj_0 *_block_obj, int flags=0) : obj(_obj), block_obj(_block_obj->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
以上为下面题目分析1中block捕获变量被装换的结构体

## 3.3 __block 中的forwarding指针
forwarding成员变量在__block变量对应的结构体中，而不是在block对应的结构体中。
栈block copy之后，无论栈还是堆上结构体的forwarding都指向堆上的__block 变量对应的结构体，因此它的效果是
> 无论__block变量在堆上还是在栈上，都能正确的访问__block变量

# 4 循环引用

1.arc下block用什么描述，为什么？
用copy/strong 都可以，在block赋值时，会对其进行copy操作，同时也对捕获的变量retain一次，防止在作用域过去之后，捕获的变量释放掉

2.weak-strong dance 解释
weak的作用：解除循环引用
strong的作用：防止在block执行的时候，weak指针指向的对象被释放；当block执行完成时，strong指针作用域结束，不会影响对象的释放

#  5 题目分析
## 题目1
```
__block id block_obj = [[NSObject alloc]init];

    id obj = [[NSObject alloc]init];

    NSLog(@"block_obj = [%@ , %p] , obj = [%@ , %p]",block_obj , &block_obj , obj , &obj);

    void (^myBlock)(void) = ^{

        NSLog(@"***Block中****block_obj = [%@ , %p] , obj = [%@ , %p]",block_obj , &block_obj , obj , &obj);

    };
    myBlock();
```
无论ARC还是MRC, 1和3都一样，因为是打印的对象地址
在ARC下，2和4 都变了，因为ARC下会对myblock(因为block被strong描述了)进行copy（浅拷贝）,因此指针是不同的
在MRC下，2不变，4变了。因为MRC不会对捕获的变量copy，2是通过forwarding指针的访问的，因此是一样的；所以4是block结构体新生成的指针，地址肯定不一样
```
//对应block中的打印操作
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_block_obj_0 *block_obj = __cself->block_obj; // bound by ref
  id obj = __cself->obj; // bound by copy

        NSLog((NSString *)&__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_1,(block_obj->__forwarding->block_obj) , &(block_obj->__forwarding->block_obj) , obj , &obj);
    }
```
参考文章：https://www.jianshu.com/p/ee9756f3d5f6

## 题目2
判断是否会循环引用
```
- (void)viewDidLoad {
    [super viewDidLoad];
    NSNotificationCenter *__weak center = [NSNotificationCenter defaultCenter];
    //直接使用 token 会有警告，block内使用了未初始化的变量，因此使用__block描述
    id __block token = [center addObserverForName:UIApplicationDidEnterBackgroundNotification
                                   object:nil
                                    queue:[NSOperationQueue mainQueue]
                               usingBlock:^(NSNotification * _Nonnull note) {
        [self doSomething];
        [center removeObserver:token];
    }];
}

- (void)doSomething {
    
}

```
1.会循环引用。token 持有block, block 持有token 造成引用循环；且block也持有的self 造成控制器也无法释放。

2.为什么token 会持有block？与系统实现有关，可打断点观察.

3.解决办法
block内手动设置token = nil; （需要执行block 才可）
token也使用__weak说明符id __block __weak token。

链接：https://juejin.cn/post/6844904145283973127






