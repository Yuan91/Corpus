# 启动优化准备知识

## ASLR
1.什么是aslr
ASLR，Address Space Layout Randomization，又称地址空间随机化。**将动态库加载到地址空间的随机位置，解决攻击者跳转到内存特定位置来破坏程序功能的意图。**

2.使用要求
只有**位置无关的可执行文件(PIE)的**可执行程序才可以最大程度利用ASLR，因为只有这样可执行文件的代码块才能被加载到随机的位置。

以Linux 32位为例，共享库会被固定加载在0x40000000的起始地址上。通过查看dyld的源码iOS模拟器和i386架构也是如此。

因此**ASLR技术主要用在动态库在虚拟地址空间的随机装载。**

3.带来的副作用
需要fix-up ，因为地址随机，动态库的加载地址相对原来会有一个偏移，偏移的计算公式
```
Slide = actual_address - preferred_address
```
dyld需要pre-main阶段修复这个偏移(slide)

4.其他
**ASLR也可以给应用地址添加随机偏移！！！（是不是呀）**
详见：
https://www.jianshu.com/p/82bbec16f86a
https://www.dllhook.com/post/58.html
```
获取ASLR命令行，程序启动时
image list -o -f | grep yourappname
程序内获取：
intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i);
```


参考：
https://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/
https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5
https://zhuanlan.zhihu.com/p/58419878

## mmap
1.iOS中用这个干什么？
将MachO文件映射到进程虚拟空间中。

2.什么是mmap
mmap 提供一种机制，将文件映射到进程的虚拟地址空间；映射之后，进程就可以采用指针的方式直接读写这一段内存，而系统会自动写dirty page到硬盘，即完成了文件的读写操作，而不用调用read、write函数。

3.直观展示
```
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
```
- start: 虚拟地址空间的起始地址
- length: 映射的长度。（在文件和地址空间的长度一致，且都是页长度的整数倍。在Linux32位系统上一页是4K，在iOS上是16K）
- prot:权限，即read/wirte/exec
- flags:映射页是否可以共享
- fd: 有效的文件描述词，不必关心，设为-1即可
- offset: 被映射内容，在文件内的偏移

4.它有什么优势
简答：
常规的文件操作，如read/wirte，需要**从硬盘 -> 页缓存 -> 用户主存，需要经历两次拷贝；**
**mmap则是直接 硬盘 -> 用户主存，省去了一次拷贝，效率更高。**

>详细：
1.常规的文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。
2.这样造成需要先将文件页从磁盘拷贝到页缓存中，而页缓存在内核中，用户进程无法直接使用，所以还需要将内容从页缓存拷贝到用户空间中。这样经历了两次拷贝操作才完成了文件的读取操作。
3.写操作同样是两次拷贝：写文件的buffer在内核中，需要拷贝到内核空间对应的主存，在拷贝到磁盘（延迟写回）
4.mmap创建虚拟内存区域(VMA)和建立VMA与文件的映射，并不存在拷贝，只有当访问对应的内存页出现page fault时，才会通过一次拷贝，将数据从硬盘读到内存的用户空间中。

## mmap原理
以Linux为例，它用VMA来描述虚拟内存虚拟区域，不同区域的起始地址和权限都一样，因此一个进程可以使用多个VMA管理内存，VMA之间同时用链表和红黑树组织。mmap函数就是要创建一个VMA，并与文件的物理地址联系起来
![VMA与虚拟地址空间](media/16422348949304/VMA%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

### 第一步 创建虚拟内存区域(VMA)
1.调用mmap，在进程的地址空间中，申请一段满足大小要求的空闲区域
2.创建VMA数据结构，并且初始化
3.将VMA插入到链表和红黑树中

### 第二步 建立VMA和文件的映射
比较晦涩，不在细说。
需要说明的是：**这一步完成之后，并未将文件读到用户主存中。**

### 第三步 page fault
1.当程序读取内存中对应的页时，通过查询页表，发现其并不在物理内存中，触发page fault缺页异常
2.把缺少的页从硬盘读到内存
3.程序从发生异常的地方重新执行

参考文章：
https://www.cnblogs.com/huxiao-tee/p/4660352.html
https://baike.baidu.com/item/mmap/1322217


## SharedCache
它的含义已经发生了多次，且在dyld3版本中，它也并不是cache.
系统的动态链接库被合并成一个大的文件，保存在/System/Library/Caches/com.apple.dyld/目录下，因此原目录下的`/System/Library/Frameworks`的共享库会被删除，按不同的架构保存分别保存着。这就叫做SharedCache

这些系统库被多个应用共享。

参考：
https://iphonedev.wiki/index.php/Dyld_shared_cache
https://developer.apple.com/forums/thread/692383
